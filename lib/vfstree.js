exports.tree = {"testloop.js":{"isdir":false,"text":"(function() {\n  var n, sales, sum;\n  sum = 0;\n  sales = {\n    east: [],\n    west: []\n  };\n  for (n = 0; n <= 2000000; n++) {\n    sales.west.push(10);\n    sales.east.push(100.1);\n  }\n  console.log(\"Start\");\n  for (n = 0; n <= 2000000; n++) {\n    sum += sales.west[n] + sales.east[n];\n  }\n  console.log(\"End\");\n  console.log(\"Sum is \" + sum);\n}).call(this);\n"},"util.coffee":{"isdir":false,"text":"util = require 'util'\n\nexports.q = (arg) ->\n  if typeof arg is \"string\"\n    \"'#{arg}'\"\n  else\n    arg\n\n\nexports.guard = (obj, regex, category, func) ->\n  for prop, val of obj when typeof val is 'function' and prop.match regex\n    do (prop, val) ->\n      obj[prop] = (args...) ->\n        if func prop, category, args...\n          val.call obj, args...\n        else\n          false\n\nexports.inseries = (funcs) ->\n  (args...) ->\n    for func in funcs when typeof func is \"function\"\n      func args...\n    true\n"},"form":{"isdir":true,"jsclient.coffee":{"isdir":false,"text":"\n#startexports\n\nsavefields = {}\n\nsavefields.textfield = (fieldname, typename) ->\n  tosave[typename] = $(fieldname).val()\n\nsavefield = (typename, fieldname, fieldval) ->\n\nentrybutton = (type) ->\n  for name, val in type when name.indexOf('_') isnt name.length-1\n    savefield val.type, name, type.name_\n\n    #copy from input field, checkbox etc.\n    #into object\n\n\n#entrybutton\n#when they click the button\n#add a new record\n#with the data\n#they entered\n\n#for each field\n#get the value\n#assign it to the object\n#\n#save the object in the database\n#before saving object check permissions\n\n\n"},"client.coffee":{"isdir":false,"text":"\n#startexports\nentryfields = {}\n\ninputentry = (name, type) ->\n  mustinclude headitems, jquery\n  input\n    type: type\n    name: name\n    id: \"#{name}_\"\n\nentryfield = (field) ->\n  if entryfields[field.type]? then entryfields[field.type](field.name)\n\nentryfields =\n  boolean: (name) ->\n    inputentry  name, 'checkbox'\n  text: (name) ->\n    inputentry name, 'text'\n\nentrybutton = (entity, msg) ->\n  button { id: \"btn#{entity.name_}\" }, msg\n\n\n"},"files":true},"testloop.coffee":{"isdir":false,"text":"sum = 0\nsales =\n  east: []\n  west: []\n\nfor n in [0..2000000]\n  sales.west.push 10\n  sales.east.push 100.1\n\nconsole.log \"Start\"\nfor n in [0..2000000]\n  sum += sales.west[n] + sales.east[n]\n\nconsole.log \"End\"\nconsole.log \"Sum is #{sum}\"\n"},"htmlbase":{"isdir":true,"server.coffee":{"isdir":false,"text":"#startexports\n\nexpressapp = (func) ->\n  top = fs.readFileSync \"#{__dirname}/htmlbase/apphead.coffee\"\n  bottom = fs.readFileSync \"#{__dirname}/htmlbase/appfooter.coffee\"\n  text \"#{top}\\n\"\n  func()\n  text \"\\n\"\n  text \"#{bottom}\"\n\nhtmlpage = (title_, contentsfunc) ->\n  text \"app.get '/#{title_}', (req, res) ->\\n\" +\n       \"  res.render '#{title_}.html'\\n\"\n\n\n\n\n"},"apphead.coffee":{"isdir":false,"text":"util = require 'util'\n\nexpress = require 'express'\n\napp = module.exports = express.createServer()\n\nprocess.on 'uncaughtException', (err) ->\n  console.log err.message\n  console.log err.stack\n\n#app.set 'view engine', 'coffee'\napp.set 'view engine', 'ejs'\napp.set(\"view options\", { layout: false })\napp.register '.html', require('ejs')\napp.register '.coffee', require('coffeekup').adapters.express\n\napp.use require('browserify')({mount: \"#{__dirname}/loader.coffee\", require: 'util', 'fs', 'node-uuid', 'coffee-script', 'mongolian', 'drykup'})\n"},"appfooter.coffee":{"isdir":false,"text":"app.listen 3000\n"},"client.coffee":{"isdir":false,"text":"\n#startexports\ndoctype = (x...) -> doctype_ x...\n\nhtml = (x...) -> html_ x...\n\nhead = (x...) -> head_ x...\n\nbody = (x...) -> body_ x...\n\ninput = (x...) -> input_ x...\n\nbutton = (x...) -> button_ x...\n\nh1 = (x...) -> h1_ x...\n\np = (x...) -> p_ x...\n\ntext = (x...) -> text_ x...\n\ntitle = (x...) -> title_ x...\n\nscript = (x...) -> script_ x...\n\nheaditems = []\n\nhtmlhead = (title_) ->\n  head ->\n    title title_\n    for item in headitems\n      (item() for item in headitems).join() if headitems?\n\nhtmlpage = (title_, contents) ->\n  newfile title_\n  doctype 5\n  html ->\n    defer ->\n      htmlhead title_\n         \n    body ->\n      contents()\n      script src: '/browserify.js', ->\n       \n\njquery = ->\n  script src: '//ajax.googleapis.com/ajax/libs/jquery/1.5.1/jquery.min.js', ->\n\nexpressapp = (func) ->\n  func()\n  \n"},"files":true},"security":{"isdir":true,"server.coffee":{"isdir":false,"text":"q = cureutil.q\n\n#startexports\n\nexpressapp = (func) ->\n  text \"security = require './lib/security/security'\"\n\naddpermission = (group, object, operation) ->\n  text \"security.addpermission #{q(group)}, #{q(object)}, #{q(operation)}\"\n"},"security.coffee":{"isdir":false,"text":"util = require 'util'\n\npermissions = {}\n\naddpermission = (group, object, operation) ->\n  if not permissions[group]? then permissions[group] = {}\n  grp = permissions[group]\n  if not grp[object]? then grp[object] = {}\n  ops = grp[object]\n  ops[operation] = true\n  \ncheckobj = (obj, prop, func) ->\n  if obj? and (obj[prop]? or obj['all']?)\n    func obj[prop]\n  else\n    false\n\ncheckpermission = (group, object, operation) ->\n  ret = checkobj permissions[group], object, (ops) ->\n    checkobj ops, operation, -> true\n  if not ret\n    checkobj permissions['all'], object, (ops) ->\n      checkobj ops, operation, -> true\n  \nexports.addpermission = addpermission\n\nexports.currentgroup = currentgroup = 'guests'\n\nexports.dbaccess = (name, category, args...) ->\n  checkpermission currentgroup, category, name\n"},"files":true},"main":{"isdir":true,"types.coffee":{"isdir":false,"text":"\ntodo =\n  version_: 1\n  name_: 'todo'\n  done: boolean 'done'\n  description: textfield 'description'\n  archived: boolean 'archived'\n\n  \n"},"main.coffee":{"isdir":false,"text":"\nshown = ->\n  and: [\n    archived: false\n    done: false\n  ]\n\nexports.run = ->\n  expressapp ->\n    addpermission 'guests', 'todo', 'all'\n    htmlpage 'todo', ->\n      entryfield todo.description\n      entrybutton todo, 'add'\n      #linebreak\n      #count todo, shown\n      #text ' remaining'\n      #actionbutton ->\n      #  update todo, { done: true },\n      #    archived: true\n      #linebreak\n      #list todo,\n      #  criteria: shown\n      #  template: ->\n      #    entryfield todo.done\n      #    showfield todo.description\n\n    htmlpage 'about', ->\n      h1 'About'\n      p 'Hello, this is about..'\n \n \n"},"tmp__dcd96769-559c-4855-b30b-0df1aa17c15e.coffee":{"isdir":false,"text":"\n#startexports\nboolean = (name) ->\n  type: 'boolean'\n  name: name\n\ntextfield = (name) ->\n  type: 'text'\n  name: name\n\n\ntodo =\n  version_: 1\n  name_: 'todo'\n  done: boolean 'done'\n  description: textfield 'description'\n  archived: boolean 'archived'\n\n  \ngen = require '../generators'\n{ replacedeferred_funcs,replacedeferred,deferred,defer_funcs,defer,mustinclude_funcs,mustinclude,outfile,newfile_funcs,newfile,currgen,text_funcs,text,expressapp_funcs,expressapp,addpermission_funcs,addpermission,doctype_funcs,doctype,html_funcs,html,head_funcs,head,body_funcs,body,input_funcs,input,button_funcs,button,h1_funcs,h1,p_funcs,p,title_funcs,title,script_funcs,script,headitems,htmlhead_funcs,htmlhead,htmlpage_funcs,htmlpage,jquery_funcs,jquery,entryfields,inputentry_funcs,inputentry,entryfield_funcs,entryfield,entrybutton_funcs,entrybutton,savefields,savefield_funcs,savefield} = gen.functions\ngen = require './generators'\n\nshown = ->\n  and: [\n    archived: false\n    done: false\n  ]\n\nexports.run = ->\n  expressapp ->\n    addpermission 'guests', 'todo', 'all'\n    htmlpage 'todo', ->\n      entryfield todo.description\n      entrybutton todo, 'add'\n      #linebreak\n      #count todo, shown\n      #text ' remaining'\n      #actionbutton ->\n      #  update todo, { done: true },\n      #    archived: true\n      #linebreak\n      #list todo,\n      #  criteria: shown\n      #  template: ->\n      #    entryfield todo.done\n      #    showfield todo.description\n\n    htmlpage 'about', ->\n      h1 'About'\n      p 'Hello, this is about..'\n \n \n"},"files":true},"includes":{"isdir":true,"server.coffee":{"isdir":false,"text":"text_ = gen.dk.text\n"},"all.coffee":{"isdir":false,"text":"#util = require 'util'\n#cureutil = require '../util'\n#`gen = require '../generators'\n\n"},"client.coffee":{"isdir":false,"text":"#{doctype, title, html, head, body, script, span, div, style, h1, h2, h3, ul, li, dl, dd, dt, table, tr, thead, td, th, tbody, tfoot, colgroup, input, text} = gen.dk\ndoctype_ = gen.dk.doctype\ntitle_ = gen.dk.title\nhtml_ = gen.dk.head\nhead_ = gen.dk.head\nbody_ = gen.dk.body\nscript_ = gen.dk.script\nspan_ = gen.dk.span\ndiv_ = gen.dk.div\nstyle_ = gen.dk.style\nh1_ = gen.dk.h1\ntext_ = gen.dk.text\ninput_ = gen.dk.input\nbutton_ = gen.dk.button\np_ = gen.dk.p\n"},"types.coffee":{"isdir":false,"text":"{ boolean, text, number } = gen.generators.types.funcs\n{ defer, mustinclude } = gen.generators.client.funcs\n\n"},"main.coffee":{"isdir":false,"text":"gen = require '../generators'\n"},"files":true},"base":{"isdir":true,"server.coffee":{"isdir":false,"text":"#startexports\n\ntext = (x) -> text_ x\n\n"},"busrc":{"isdir":true,"page.coffee":{"isdir":false,"text":"#Page\n\n#to indicate that a DragDroppable\n#component requires jquery\n#in designer view\n#drag a jquery object into\n#the head container \n#for the page stand-in\n#so there is a mechanism\n#to fypeind the parent parent\n#which is a page or other object\n#and marked as a standin\n\n#htmlpage defined\n#as a series\n#of containers\n#head is first and its a series\n#body is also a series\n\n\n###\ntypes.add [\n\n  htmlopentag:\n    outputs: '<', \"{tagname}\", '>'\n\n  htmlclosetag:\n    outputs: '</', \"{tagname}\", '>'\n\n  htmlelement:\n    outputs:\n      \"{htmlopentag}\"\n      \"{contents}\"\n      \"{htmlclosetag}\"\n    contents:\n      isA: 'list htmlelement'\n]\n\ndata.add [\n  body:\n    isA: 'htmlelement'\n    tagname: 'body'\n\n  html:\n    isA: 'htmlelement'\n    tagname: 'html'\n    contents: 'body'\n    \n  doctype:\n    isA: 'htmlelement'\n    tagname: '!doctype html'\n \n  htmlpage:\n    html: 'html'\n    outputs: [ \"{doctype}\", \"{html}\" ]\n      \n\n]\n###\n\n#open tagname close\n#open tagname attributes close\n#  contents\n#openstop tagname close\n\n\n#purpose of all of this is\n#to make it easy to output\n#html pages\n#based on page/component definitions\n#using a data-oriented approach\n#so that only core has\n#to be ported to other platforms\n#while models, components and data\n#don't have to be ported\n\n#can you get it to just output an html page\n#with a head, title, body 'hello world'\n#based on this more general model\n#which might be page\n\n#how to I associate\n#page with html page\n#say its a view\n\nx = \"{blah}\"\n\nmypage:\n  type: 'page'\n  contents: [\n    text: 'Hello World.'\n  ]\n\nelementviewer:\n  type: 'htmlelement'\n  context: 'html'\n  outputs: \"#{obj.tagname}\"\n    \n\nspanviewer:\n  type: 'span'\n  context: 'html'\n  outputs:\n    htmlelement:\n      tagname: 'span'\n      contents: \"#{obj.text}\"\n\ntextviewer:\n  type: 'text'\n  context: 'html'\n  outputs:\n    span:\n      text: \"#{obj.val}\"\n\npageviewer:\n  matchestype: 'page'\n  context: 'html'\n  outputs:\n    htmlpage:\n      title: \"#{obj.title}\"\n      body: \"#{obj.contents}\"\n\nfirstproperty = (obj) ->\n  props = prop for prop of obj\n  props[0]\n\ncreate = (obj) ->\n  #get the first property\n  #assume this is the only property\n  #assume the property name is a type name\n  #create an object of that type\n  #with those properties\n  prop = firstproperty obj\n  newobj = {}\n  newobj[prop] = obj[prop]\n\n\n\nclass Thing\n  concat: (thing) ->\n     \n\nclass Processor extends Thing\n  constructor: (@func) ->\n    \n  process: (obj, out) ->\n    out = []\n    if obj.children?\n      childout = child.process for child in obj.children\n     \n    func obj, out\n  \n\noutputprocessor:\n  matchestype: 'any'\n  context: 'any'\n  property: 'outputs'\n  process: (obj) ->\n    if typeof obj is 'string'\n      obj\n    else\n      create obj\n\nview 'mypage' 'html'\n\n#when I call view how do I lookup the correct generator\n#and then generate the code\n#lookup the object\n#what is the type\n#once I know the type\n#find a view for that type and context\n#need a way to search through objects\n#to match a certain property value\n\n#once I find that view\n#then I need to generate the outputs\n#how does one generate outputs?\n#look at the outputs array\n#for each item, generate\n#to generate an item\n#if its literal text, output that text to current context stream\n#if its in curly braces, lookup that item\n#then call output on that object\n \n\n"},"component.coffee":{"isdir":false,"text":"meta:\n  proto:\n    isType: false\n    name: ''\n    default:\n    value: ''\n    type: ''\n    childrenType: ''\n    children: []\n    properties: {}\n    propertyOrder: []\n    values: {}\n\n  #property type is proto\n  #unless otherwise specified\n\n  attribute:\n    isType: true\n    name: 'attribute'\n    properties:\n      name:\n        type: 'String'\n      value:\n        type: 'string'\n    \n\n  htmlAttributes:\n    isType: true\n    type: 'proto'\n    name: 'htmlAttributes'\n    childrenType: 'attribute'\n\n  map:\n    isType: true\n    type: 'proto'\n    properties:\n      onType:\n        default: true\n        type: 'Boolean'\n      from:\n        type: 'proto'\n      to:\n        type: 'proto'\n\n  serial:\n    isType: true\n    name: 'serial'\n    type: 'map'\n    properties:\n      outList:\n        type: 'Array'\n           \n\n  htmlAttributeSerial:\n    isType: false\n    type: 'serial'\n    \n    values:\n      from: 'html'\n      to: 'taggedMarkup'\n      outList: [ 'name', '=', 'value' ]\n\n  htmlTagSerial:\n    isType: false\n    type: 'serial'\n    values:\n      from: 'htmlTag'\n      to: 'taggedMarkup'\n      outList: [ '<', 'name', 'attributes', '>' ]\n\n          \n  html:\n    isType: true\n    name: 'html'\n    type: 'HTMLTag'\n    properties:\n      htmlTagName:\n        default: 'html'\n    children: [\n      head:\n        isType: false\n        type: 'HTMLTag'\n        values:\n          htmlTagName: 'head'\n      body:\n        isType: false\n        type: 'HTMLTag'\n        values:\n          htmlTagName: 'body'\n    ]\n \n  docType:\n    isType: false\n    name: 'docType'\n    type: 'html'\n    values:\n      htmlTagName:\n        default: '!DOCTYPE'\n\n  \n  script:\n    isType: true\n    name: 'script'\n    type: 'htmlTag'\n    properties:\n      htmlTagName:\n        default: 'script'\n      attributes:\n         default: [\n           name: 'type'\n           value: 'text/javascript'\n         ]\n              \n  jQuery:\n    isType: false\n    name: 'jQuery'\n    type: 'script'\n    values:\n      contents:\n        attributes:  [\n          name: 'src'\n          value: 'js/jQuery.min.js'\n        ]\n \n  mapList:\n    type: 'proto'\n    childrenType: 'map'\n   \n  generator:\n    type: 'proto'\n    properties:\n      from:\n        type: 'proto'\n      mapsTo:\n        type: 'mapList'\n     \n\n  generatorList:\n    type: 'proto'\n    childrenType: 'generator'\n\n  operator:\n\n  conditional:\n    type: 'proto'\n    properties:\n      expr1:\n        type: 'expresson'\n      expr2:\n        type: 'expression'\n      comparison:\n        type: 'operator'\n        default: '='\n  \n \n  conditionalInsertion:\n    type: 'conditional'\n    \n\n  dependency:\n    type: 'conditionalInsertion'\n    properties:\n      \n\n  requiresList:\n    type: 'proto'\n    childrenType: 'dependency'\n\n  \n\n  component:\n    name: 'component'\n    properties:\n      requires:\n        type: 'requiresList'\n      generators:\n        type: 'generatorList'\n      \n          \n\n\n#metalevel\n#is basically a slot\n#might be screen (html)\n#or program (for logic)\n\n\n#defines \n     \n#programs as data\n\n#this is key\n#everything is data\n\n\n \nclass Tag extends Slot\n  @constructor (start, contents, end) ->\n    @list = [\n    @start = start\n    @contents = contents\n    @end = end\n\nitem = new Slot\n  [\n    'start',\n    'contents',\n    'end'\n  ]\n\ntag = new Slot\n  is:\n    'item'\n    start: ''\n\nhtml = new Slot\n  html: [\n    'head'\n    body:\n      is: 'item'\n      start:\n      contents:\n      end:\n  ]\n\n\n#A box that you can drag around on the screen\n#and that can be dropped inside of other boxes\n#and then when generate is called\n#outputs a serialized representation of itself\n#and whatever is inside\n#assume box just has a name and children\n\nclass Component\n  constructor: (@name) ->\n\n  out: (slot) ->\n    #go to that slot\n    #output the value\n\nclass head extends item\n\n\nclass link\n  constructor: ->\n    out:\n      head:\n        start:\n\n        contents:\n\n        end:\n\nclass jQuery\n  constructor: ->\n    out:\n      link:\n             \n\nclass WebNamedContainer\n  constructor: (@text) ->\n    requires: 'jquery'\n    @out =\n        \n"},"component.js":{"isdir":false,"text":"(function() {\n  var html;\n  html = new Slot({\n    html: [\n      'head', {\n        body: ['top', 'main', 'end']\n      }\n    ]\n  });\n}).call(this);\n"},"example.coffee":{"isdir":false,"text":"#[enter todo here______________] <add>\n#1 remaining <clean up>\n#  x (struck)learn angular\n#  _ build an angular app\n\ntypes =\n  todo: [\n    done: 'boolean'\n    description: 'text'\n    archived: 'boolean'\n  ]\n\ndata =\n  collections: [ todos: 'todo' ]\n\nviews = [\n  todoitem:\n    type: 'todo'\n    context: 'itemstyle'\n    condition: [ 'done', '=', 'true' ]\n    style: 'text-decoration: line-through'\n  todoentry:\n    type: 'todo'\n    context: 'entryform'\n    hidden: 'archived'\n]\n\ncomponents =\n  todo: [\n    entry: 'todo'\n    separator: '\\n'\n    count:\n      collection: 'todo'\n      done: false\n      archived: false\n    text:\n      ' remaining'\n    action:\n      update:\n      collection: 'todo'\n      where:\n        criteria: [ 'user', '=', currentUser, 'and', 'done', '=', 'true' ]\n        set: [ archived: true ]\n    list:\n        collection: 'todo'\n        filters: [ archived: false ]\n  ]\n      \npages =\n  index: [ 'todo' ]\n     \n\n"},"generators.coffee":{"isdir":false,"text":"ck = require 'coffeekup'\nutil = require 'util'\nfs = require 'fs'\nuuid = require './souuid'\n\nmergeover = (object, properties) ->\n  for key, val of properties\n    object[key] = val\n  object\n\nserv = {}\ncli = {}\n\ndeferred = {}\n\ndefer = (args) ->\n  console.log 'inside of defer'\n  console.log 'args is ' + args\n  uuid = guid()\n  console.log 'guid is ' + guid\n  @deferred[uuid] = args\n  ret = '{def' + uuid + '}'\n  console.log 'returning ' + ret\n  text ret\n\nreplacedeferred = (rendered) ->\n  defers = rendered.match /\\{def.+\\}/gi\n  console.log 'deferred is ' + @deferred\n  for key, val of @deferred\n    console.log key + ':' + val\n\n  for found in defers\n    console.log '1'\n    uuid = found.substr 4\n    console.log '2'\n    uuid = uuid.substr(0, uuid.length-1)\n    console.log '3'\n    console.log 'deferred at uuid ' + uuid + ' is ' + @deferred[uuid]\n    rendered = rendered.replace found, @deferred[uuid]()\n  text rendered\n    \ndeferredtemplate =  ->\n  replacedeferred @rendered, @deferred\n\nclass FileGenerator\n  constructor: (@name, @path) ->\n    @funcs = {}\n\n  add: (funcs) ->\n    @funcs = mergeover @funcs, funcs\n  \n  run: (@template, name) ->\n    output = ck.render template, deferred: deferred, hardcode: @funcs\n    console.log 'output is ' + output\n    output = ck.render(deferredtemplate, {deferred: deferred, rendered: output}, hardcode: @funcs)\n\n    fs.writeFile @path + '/' + name, output, (err) ->\n      if err then console.log err\n\ngenerators =\n  client: new FileGenerator 'client', 'views'\n  server: new FileGenerator 'server', ''\n\ngenerators.client.add\n  replacedeferred: replacedeferred\n  deferred: deferred\n\ngenerators.client.add uuid\n\nfor key, val of ck\n  generators.client.funcs[key] = val\n\nexports.generators = generators\n\nmustinclude = (items, item) ->\n  console.log 'inside of mustinclude '\n  console.log 'items is ' + items\n  console.log 'item is ' + item\n  if not (item in items)\n    console.log 'adding item'\n    items.push item\n  else\n   console.og 'not adding item'\n\nclientfuncs =\n  headitems: []\n\n  mustinclude: mustinclude\n\n  defer: defer\n\n  htmlhead: (title_) ->\n    console.log '***** inside of htmlhead *****'\n    head ->\n      title title_\n      console.log 'headitems is ' + headitems\n      for item in headitems\n        console.log 'item is ' + item\n        console.log 'return of item is ' + item()\n        console.log 'ckrender of item is ' + render item, null\n      (item() for item in headitems).join() if headitems?\n\n  htmlpage: (title_, contentsfunc) ->\n    doctype 5\n    html ->\n      defer ->\n        htmlhead title_\n         \n      body ->\n        contentsfunc()\n\n  jquery: ->\n    '<script src=\"js/jquery.js></script>'\n    #script src: 'js/jquery.js'\n\n  entry: (field) ->\n    mustinclude headitems, jquery\n    input field\n\nserverfuncs =\n  htmlpage: (title_, contentsfunc) ->\n    text \"apage = ->\\n\" +\n         \"  htmlpage '\"+title_+\"', '\" + contentsfunc() +\"'\\n\"\n\n    text \"app.get '/#{title_}', (req, res) ->\\n\" +\n         \"  res.render '#{title_}'\\n\"\n\n  mustinclude: mustinclude\n\ngenerators.client.add clientfuncs\ngenerators.server.add serverfuncs\n\n\n"},"views.coffee":{"isdir":false,"text":"objects = {}\n\nclass Thing\n  @find (prop, val) ->\n    propmatches = prop for prop in @ when @[prop]? and @[prop] is val\n    if propmatches? and propmatches.length > 0\n      propmatches\n    else\n      obj for obj in objects when obj[prop]? and obj[prop] is val\n  \n  @findfirst (prop, val) ->\n    first find prop, val\n\n  @first (arr) ->\n    arr[0]\n\n  @parseid (text, func) ->\n    if text.substr(0) == '{'\n      name = o.substr(1)\n      name = name.substr(0, name.length-1)\n      @[name][func]()\n    else\n      text\n    \n\n  @generate (obj) ->\n    outs = o for o in outputs\n    if o.substr(0) == '{'\n      name = o.substr(1)\n      name = name.substr(0, name.length-1)\n      #o2 =  \n    else\n      \n\n  @view (context) ->\n    view = @find @type context\n    view.generate @\n\n#when I call view how do I lookup the correct generator\n#and then generate the code\n#lookup the object\n#what is the type\n#once I know the type\n#find a view for that type and context\n#need a way to search through objects\n#to match a certain property value\n\n#once I find that view\n#then I need to generate the outputs\n#how does one generate outputs?\n#look at the outputs array\n#for each item, generate\n#to generate an item\n#if its literal text, output that text to current context stream\n#if its in curly braces, lookup that item\n#then call output on that object\n\n  \n\n#lookup ->\n  \n"},"files":true},"types.coffee":{"isdir":false,"text":"\n#startexports\nboolean = (name) ->\n  type: 'boolean'\n  name: name\n\ntextfield = (name) ->\n  type: 'text'\n  name: name\n\n"},"tmp__server.coffee_bfa3fc50-2e09-4411-966a-4396e54e535b.coffee":{"isdir":false,"text":"util = require 'util'\ncureutil = require '../util'\ngen = require '../generators'\ntext_ = gen.dk.text\n\n{ replacedeferred_funcs,replacedeferred,deferred,defer_funcs,defer,mustinclude_funcs,mustinclude,outfile,newfile_funcs,newfile,currgen} = gen.generators.server.funcs\n#startexports\n\ntext = (x) -> text_ x\ngen.addAll 'server', {text:text}"},"tmp__server.coffee_30664a18-8611-4a17-84ea-fe68a6a490fd.coffee":{"isdir":false,"text":"util = require 'util'\ncureutil = require '../util'\ngen = require '../generators'\ntext_ = gen.dk.text\n\n{ replacedeferred_funcs,replacedeferred,deferred,defer_funcs,defer,mustinclude_funcs,mustinclude,outfile,newfile_funcs,newfile,currgen} = gen.generators.server.funcs\n#startexports\n\ntext = (x) -> text_ x\ngen.addAll 'server', {text:text}"},"files":true},"busrc":{"isdir":true,"test":{"isdir":true,"curemongo-test.js":{"isdir":false,"text":"(function() {\n  var assert, curemongo, util, vows;\n  vows = require('vows');\n  assert = require('assert');\n  curemongo = require('../mongo');\n  util = require('util');\n  vows.describe('Cure Mongo module').addBatch({\n    'A test database': {\n      topic: function() {\n        return curemongo.getDB('test');\n      },\n      'returns an object': function(db) {\n        assert.isObject(db);\n      },\n      topic: function() {\n        var db;\n        db = curemongo.getDB('test');\n        try {\n          db.dropCollection('chairs', function() {\n            return db.createCollection('chairs', this.callback);\n          });\n        } catch (e) {\n\n        } finally {\n          db.createCollection('chairs', this.callback);\n        }\n      },\n      'made a collection named chairs': function(err, res) {\n        assert.isNull(err);\n        assert.include(res, 'collectionName');\n        return assert.equal(res.collectionName, 'chairs');\n      },\n      'after inserting a chair': {\n        topic: function(chairs) {\n          return chairs.insert({\n            wood: 'mahogany',\n            style: 'victorian'\n          });\n        },\n        'now contains the mahagony chair': function(err, res) {\n          assert.isNull(err);\n          return assert.isTrue((res.find({\n            wood: 'mahogany'\n          }).toArray().length) > 0);\n        }\n      }\n    }\n  })[\"export\"](module);\n}).call(this);\n"},"alltest.coffee":{"isdir":false,"text":"vows = require 'vows'\nassert = require 'assert'\ntodos = require '../main/todos'\n\nutil = require 'util'\n\nvows\n  .describe('Plugins + Generators + Todo + Page')\n  .addBatch\n    'Todo':\n      topic: ->\n        result = todos.generate()\n    \n      'returns true': (result) ->\n        assert.isTrue result\n  \n  .export module\n\n"},"curemongo-test.coffee":{"isdir":false,"text":"vows = require 'vows'\nassert = require 'assert'\ncuremongo = require '../mongo'\nutil = require 'util'\n\nvows\n  .describe('Cure Mongo module')\n  .addBatch\n    'A test database':\n      topic: ->\n        curemongo.getDB 'test'\n    \n      'returns an object': (db) ->\n        assert.isObject db\n        return\n  \n      topic: ->\n        db = curemongo.getDB 'test'\n        try\n          db.dropCollection 'chairs', ->\n            db.createCollection 'chairs', @callback\n        catch e\n        finally\n          db.createCollection 'chairs', @callback\n        return\n      \n#      'made a collection named chairs': (err, res) ->\n#        assert.isNull err\n#        assert.include res, 'collectionName'\n#        assert.equal res.collectionName, 'chairs'\n      \n#      'after inserting a chair':\n#        topic: (chairs) ->\n#          chairs.insert\n#            wood: 'mahogany'\n#            style: 'victorian'\n#        \n#        'now contains the mahagony chair': (err, res) ->\n#          assert.isNull err\n#          assert.isTrue ( res.find({wood:'mahogany'}).toArray().length ) > 0\n##   \n  .export module\n\n"},"views-test.coffee":{"isdir":false,"text":"vows = require 'vows'\nassert = require 'assert'\nutil = require 'util'\n\n#NOTE: CRAZY FUCKING IDEA: USE COFFEESCRIPT\n#WORRY ABOUT SERIALIZATION AND GUI LATER\n#JUST PUT GUIDS ON ALL OBJECTS\n\nvows\n  .describe 'Test views infrastructure'\n\n  .addBatch 'Objects as instances of types'\n    #given a type description\n    #an object described as that type\n    #has the properties of that type\n\n   #context can have subcontext\n   #html context can have server and\n   #client context\n\n   #can view/context/type relation be\n   #abstracted to simply type relationship?\n   #relation is htmview\n   #generaltype is view\n   #or generatedview\n   #or serialview\n   #serialview describes the order\n   #that certain properties are output\n   #or input as \n\n   #a component might relate to a page object\n   #and serialization handled by the page object\n   #rather than in the component\n\n   #so the specific component doesn't know\n   #about jquery\n   #but some general widget component\n   #must know about it\n   #for example htmlentry\n   #requires jquery to validate\n   #on change\n\n   #so how does the jquery eventually get included in the page?\n   #the entry is included\n   #the html serialview for entry\n   #has a requires: jquery\n   #jquery is defined as \n   #adding the script to head\n   #so its a script element added to head which is a list\n   #of elements\n   #requires: means if that item isn't already there\n   #then add it to the list specified\n\n   #can requires: and outputs: be defined\n   #as processor objects or something\n\n\n\n  .addBatch 'Properties associated with processors'\n\n  .addBatch 'Reference instances or properties in {}'\n    #if a property value is text in curly braces\n    #that means it is a lookup and gets assigned\n    #either the corresponding named property\n    #or the object matching that name\n\n  .addBatch 'Walk through an object tree calling a function on all children'\n    # \n\n  .addBatch 'Views associate generator types for each context'\n    #Given an object with contents (children) of different types\n    #to generate a view in a certain context\n    #find the corresponding view type for that context starting with\n    #the parent context, call generate and and walking through each child\n    #property and child  \n\n  .addBatch 'Generator views can generate serial output'\n        \n\n  .addBatch\n    'Lookup properties and objects'\n  \n    #   \n    topic ->\n      o = new Thing\n      \n    test\n\n#form validation and html/code parsing are essentially the same thing     \n\n#input is a model also in the form of a stream or list of events\n\n#everything can be handled as data with related types\n\n#model types have a relation that expresses the fact that certain input event insertions\n#cause changes to the model, e.g. newrecord button input event means a corresponding insertion\n#in the record collection\n\n#to generalize, inserting a record into one representation automatically creates an item\n#of the corresponding type in the corresponding position in another representational tree     \n#same with updates\n#between these leaves we need converters\n\n\n#html form<------>validate<----->internal representation<----->client code<------->server representation<------>database representation\n\n\n#each representation or context is a tree of types\n#types need converters to and from\n\n#shorthand could be to use property name == type name\n\n\n"},"files":true},"testdk.js":{"isdir":false,"text":"(function() {\n  var dk;\n  dk = require('drykup')();\n  dk.head(function() {\n    return dk.title('Hello World');\n  });\n  dk.body(function() {});\n  console.log(dk.htmlOut);\n}).call(this);\n"},"withdrykup.coffee":{"isdir":false,"text":"dk = require('drykup')()\nutil = require 'util'\nfs = require 'fs'\n\nclass FileGenerator\n  constructor: (@name, @path) ->\n    @funcs = {}\n\n  exec: (funcname, args) ->\n    if @funcs[funcname]?\n      @funcs[funcname](args)\n\n  run: (@template, name) ->\n    template @exec\n    output = dk.htmlOut\n    fs.writeFile @path + '/' + name, output, (err) ->\n      if err then console.log err\n\ngenerators =\n  client: new FileGenerator 'client', 'views'\n  css: new FileGenerator 'css', 'views/css'\n  db: new FileGenerator 'db', ''\n  nodejs: new FileGenerator 'nodejs', ''\n\ncli = generators.client.funcs\n\ncli.mustinclude = (items, item) ->\n  if not (item in items)\n    items.push item\n\ncli.headitems = []\n\ncli.htmlhead = (title_) ->\n  dk.head ->\n    dk.title title_\n    (item for item in headitems).join() if headitems?\n\ncli.htmlpage = (title_, contentsfunc) ->\n  dk.doctype 5\n  dk.html ->\n    cli.htmlhead title_\n         \n    dk.body ->\n      contentsfunc()\n\ncli.jquery = ->\n  dk.script src: 'js/jquery.js'\n\ncli.entry = (field) ->\n    cli.mustinclude cli.headitems, cli.jquery\n    dk.input field\n\nserv = generators.nodejs.funcs\n\nserv.htmlpage = (title_, contentsfunc) ->\n    dk.addText \"apage = ->\\n\" +\n         \"  htmlpage '\"+title_+\"', '\" + contentsfunc() +\"'\\n\"\n\n    dk.addText \"app.get '/#{title_}', (req, res) ->\\n\" +\n         \"  res.render '#{title_}'\\n\"\n\n\ntodospage = (gen) ->\n  gen 'htmlpage', 'To-do', ->\n    gen 'entry', 'todo'\n\ngenerators.client.run todospage, 'todo'\n\n"},"testthing.js":{"isdir":false,"text":"(function() {\n  var testfunc, util;\n  util = require('util');\n  testfunc = function(x) {\n    console.log('callee is ' + arguments.callee);\n    console.log(x);\n    return console.log(util.inspect(this));\n  };\n  console.log(util.inspect(testfunc()));\n}).call(this);\n"},"testdk.coffee":{"isdir":false,"text":"dk = require('drykup')()\n\n\n\ndk.head ->\n  dk.title 'Hello World'\ndk.body ->\n\nconsole.log dk.htmlOut\n\n"},"withkup.js":{"isdir":false,"text":"(function() {\n  var FileGenerator, ck, cli, clientfuncs, fs, generators, mergeover, mustinclude, serv, serverfuncs, todospage, util;\n  var __indexOf = Array.prototype.indexOf || function(item) {\n    for (var i = 0, l = this.length; i < l; i++) {\n      if (this[i] === item) return i;\n    }\n    return -1;\n  };\n  ck = require('coffeekup');\n  util = require('util');\n  fs = require('fs');\n  mergeover = function(object, properties) {\n    var key, val;\n    for (key in properties) {\n      val = properties[key];\n      object[key] = val;\n    }\n    return object;\n  };\n  serv = {};\n  cli = {};\n  FileGenerator = (function() {\n    function FileGenerator(name, path) {\n      this.name = name;\n      this.path = path;\n      this.funcs = {};\n    }\n    FileGenerator.prototype.add = function(funcs) {\n      return this.funcs = mergeover(this.funcs, funcs);\n    };\n    FileGenerator.prototype.run = function(template, name) {\n      var output;\n      this.template = template;\n      output = ck.render(template, {\n        test: 'dummy',\n        hardcode: this.funcs\n      });\n      return fs.writeFile(this.path + '/' + name, output, function(err) {\n        if (err) {\n          return console.log(err);\n        }\n      });\n    };\n    return FileGenerator;\n  })();\n  generators = {\n    client: new FileGenerator('client', 'views'),\n    server: new FileGenerator('server', '')\n  };\n  generators.client.add({\n    require: require\n  });\n  mustinclude = function(items, item) {\n    console.log('inside of mustinclude ');\n    console.log('items is ' + items);\n    console.log('item is ' + item);\n    if (!(__indexOf.call(items, item) >= 0)) {\n      console.log('adding item');\n      return items.push(item);\n    } else {\n      return console.og('not adding item');\n    }\n  };\n  clientfuncs = {\n    headitems: [],\n    mustinclude: mustinclude,\n    htmlhead: function(title_) {\n      return head(function() {\n        var item;\n        title(title_);\n        console.log('headitems is ' + headitems);\n        if (typeof headitems !== \"undefined\" && headitems !== null) {\n          return ((function() {\n            var _i, _len, _results;\n            _results = [];\n            for (_i = 0, _len = headitems.length; _i < _len; _i++) {\n              item = headitems[_i];\n              _results.push(item);\n            }\n            return _results;\n          })()).join();\n        }\n      });\n    },\n    htmlpage: function(title_, contentsfunc) {\n      doctype(5);\n      html(function() {\n        return htmlhead(title_);\n      });\n      return body(function() {\n        return contentsfunc();\n      });\n    },\n    jquery: function() {\n      return script({\n        src: 'js/jquery.js'\n      });\n    },\n    entry: function(field) {\n      mustinclude(headitems, jquery);\n      return input(field);\n    }\n  };\n  serverfuncs = {\n    htmlpage: function(title_, contentsfunc) {\n      text(\"apage = ->\\n\" + \"  htmlpage '\" + title_ + \"', '\" + contentsfunc()(+\"'\\n\"));\n      return text((\"app.get '/\" + title_ + \"', (req, res) ->\\n\") + (\"  res.render '\" + title_ + \"'\\n\"));\n    },\n    mustinclude: mustinclude\n  };\n  generators.client.add(clientfuncs);\n  generators.server.add(serverfuncs);\n  todospage = function() {\n    return htmlpage('To-do', function() {\n      return entry('todo');\n    });\n  };\n  generators.client.run(todospage, 'todo');\n}).call(this);\n"},"testthing.coffee":{"isdir":false,"text":"util = require 'util'\n\ntestfunc = (x) ->\n  console.log 'callee is ' + arguments.callee\n  console.log x\n  console.log util.inspect @\n \n\nconsole.log util.inspect testfunc()\n"},"files":true},"plugins.coffee":{"isdir":false,"text":"module.exports = [\n  { base: on }\n  { security: on }\n  { db: on }\n  { htmlbase: on }\n  { nowjs: on }\n  { form: on }\n]\n\n"},"config.js":{"isdir":false,"text":"(function() {\n  exports.config = {\n    host: 'localhost',\n    port: 27017,\n    db: 'app'\n  };\n}).call(this);\n"},"vfs.coffee":{"isdir":false,"text":"fs = require 'fs'\n\ntree = {}\nindex = {}\nbasepath = ''\n\nsetbase = (dirpath) ->\n  basepath = dirpath\n  ret = scandir exports.tree, dirpath\n  fs.writeFileSync __dirname + '/vfstree.js', 'exports.tree = ' + JSON.stringify(tree)\n\nscandir = (parentnode, dirpath) ->\n  files = fs.readdirSync dirpath\n  for file in files\n    if file.substr(0, 1) isnt '.'\n      stats = fs.statSync \"#{dirpath}/#{file}\"\n      if stats.isDirectory()\n        parentnode[file] =\n          isdir: true\n        parentnode[file].files = scandir parentnode[file], \"#{dirpath}/#{file}\"\n      else\n        parentnode[file] =\n          isdir: false\n          text: fs.readFileSync(\"#{dirpath}/#{file}\").toString()\n        index[\"#{dirpath}/#{file}\"] = parentnode[file].text\n  true\n\nreadFileSync = (pathname) ->\n  index[pathname]\n\nexports.tree = tree\nexports.index = index\nexports.basepath = basepath\nexports.scandir = scandir\nexports.readFileSync = readFileSync\nexports.setbase = setbase\n\n"},"db":{"isdir":true,"db.coffee":{"isdir":false,"text":"MongolianDeadBeef = require 'mongolian'\n\ncureutil = require '../util'\n\nsecurity = require '../security/security'\n\nserver = new MongolianDeadBeef\n\ndb_ = server.db 'app'\n\nexports.db = {}\n\nguarded = {}\n\nexports.db.collection = (name) ->\n  if not (name in guarded)\n    col = db_.collection(name)\n    cureutil.guard col, /(.*)/, name, security.dbaccess\n    guarded[name] = col\n  guarded[name]\n\n"},"mongoold.coffee":{"isdir":false,"text":"#implements shared type dbinterface\n#for mongodb\n\ndeadbeef = require 'mongolian'\n\nconfig = require './config'\n\nconfig = config.config\n\nserver = new Mongolian\n\n#connectString = exports.connectString = \"http://#{config.host}:#{config.port}/\"\n\n#exports.db = mongo.db \"#{exports.connectString}#{config.db}\"\n\nexports.setDB = (name) ->\n  db = server.db name\n\n\n#exports.dbExists = (name, callback) ->\n#  console.log 'Inside of dbExists'\n#  dbtst = mongo.db \"#{connectString}#{name}\"\n#  console.log 'Tried to connect'\n#  callback(true)\n\nexports.getDB = (name) ->\n  db = server.db name\n  db\n\n#exports.dropDB = (name, callback) =>\n#  dbdrop = mongo.db \"#{connectString}#{name}\"\n#  dbdrop.dropDatabase name, (err, done) ->\n#    callback err, done\n\n#exports.createDB = (name, callback) =>\n#  mongo.db name, (err, done) ->\n#    callback err, done\n\nexports.load = (collection, objectid) ->\n   \n#exports.find = (collection, criteria) ->\n\n\nexports.save = (collection, object) ->\n  exports.db.insert collection, object\n\nexports.createCollection = (name, callback) ->\n  exports.db.createCollection name, callback\n\nexports.dropCollection = (name, callback) ->\n  exports.db.dropCollection name, callback\n\n\n"},"files":true},"trycompile.coffee":{"isdir":false,"text":"cs = require 'coffee-script'\nfs = require 'fs'\nutil = require 'util'\n\nconsole.log \"args: #{util.inspect process.argv}\"\n\ncode = fs.readFileSync process.argv[1]\ncode = code.toString()\nconsole.log cs.compile code, bare: on\n"},"design.txt":{"isdir":false,"text":"render some text on the page\n\nPipe/data flow style one method on each verb object: run\n\n\n\n\nSite object\n\n   Pages class\n\n     Page object\n      \n        Nav object --> mostly the same except for the current page\n                       being indicated\n\n        Content object --> display different things\n                           depending on context\n\n   Page object\n      \n      Rendered according to PageTemplate object\n      \n    \n              \nFor templating use coffeekup\n\nbut I want templates to be very small and simple\n\nUse repeat or looper object instead of loops\n\nI want a widget that I can drag around\nThen I want to be able to put them inside\nAnd edit their properties\n\nThen they generate code\nSo I am editing the template graphically\n\nhead = new Slot 'head'\n\nbody = new Slot 'body', [ 'top', 'main', 'end' ]\n  \nhtml = new Slot 'html', [ head, body ]\nhtml:\n  slots: [ head, body ]    \n\nhtml = new Slot\n  html: [\n    head\n    body: [\n      top\n      main\n      end\n    ]\n  ]\n  \n"},"oldloader.coffee":{"isdir":false,"text":"fs = require 'fs'\nplugins = require './plugins'\ngenerators = require './generators'\n#cs = require 'coffee-script'\nuuid = require 'node-uuid'\nutil = require 'util'\npathx = require 'path'\n\nfirstprop = (obj) ->\n  props = (prop for prop, val of obj)\n  props[0]\n\nfirstval = (obj) ->\n  vals = (val for prop, val of obj)\n  vals[0]\n\nstrip = (def) ->\n  def.substr(0, def.length-1).trim()\n\ndropext = (file) ->\n  file.substr 0, file.indexOf('.')\n\nwrap = (source, file) ->\n  if not file? or file is '.' or file is '..' then return ''\n  file = dropext file\n  source = (source + \" \").trim()\n  top = fs.readFileSync \"#{__dirname}/includes/all.coffee\"\n  top = (top + \" \").trim() + \"\\n\"\n  inc = ''\n  if pathx.existsSync \"#{__dirname}/includes/#{file}.coffee\"\n    inc = fs.readFileSync \"#{__dirname}/includes/#{file}.coffee\"\n  declares = ''\n  if generators.generators[file]?\n    funcs = generators.generators[file].funcs\n    if funcs? and Object.keys(funcs)? and Object.keys(funcs).length > 0\n      declares = '{ ' + Object.keys(funcs).join() + '}'\n      declares = \"#{declares} = gen.generators.#{file}.funcs\\n\"\n  bounds = \"#startexports\\n\"\n  bottom = ''\n  start = source.indexOf bounds\n  if start >= 0\n    exports = source.substr(start + bounds.length)\n    defs = exports.match /^[a-z0-9]+[ ]*[=]+/gmi\n    if defs?\n      list = (\"#{strip def}:#{strip def}\" for def in defs)\n      bottom = \"gen.addAll '#{file}', {#{list.join()}}\"\n  else\n    console.log \"No #startexports in #{file}\"\n    return ''\n  top + inc + \"\\n\" + declares + source + \"\\n\" + bottom\n\nprocess = (path, fname) ->\n  if not pathx.existsSync \"#{path}/#{fname}\"\n    false\n  else\n    stats = fs.statSync \"#{path}/#{fname}\"\n    if stats.isDirectory() then return false\n    source = fs.readFileSync \"#{path}/#{fname}\"\n    source = wrap source, fname\n    tmpname = \"#{path}/tmp__#{fname}_#{uuid.v4()}\"\n    fs.writeFileSync tmpname + '.coffee', source\n    r = require tmpname\n    fs.unlinkSync tmpname + '.coffee'\n\nloadall = (plugin) ->\n  path = \"#{__dirname}/#{plugin}\"\n  files = fs.readdirSync path\n  for f in files when f isnt 'types.coffee' and f isnt 'main.coffee' and f.indexOf('tmp__') isnt 0\n    process path, f\n  generators.makeFunctions()\n\naddgenfunctions = ->\n  funcs = generators.functions\n  declares = ''\n  if funcs? and Object.keys(funcs)? and Object.keys(funcs).length > 0\n    declares = '{ ' + Object.keys(funcs).join() + '}'\n    declares = \"#{declares} = gen.functions\\n\"\n  declares\n\nloadalltypes = (list) ->\n  source = ''\n  list.push 'main'\n  for pl in list\n    path = \"#{__dirname}/#{pl}/types.coffee\"\n    if pathx.existsSync(path)\n      source += fs.readFileSync path\n  top = fs.readFileSync \"#{__dirname}/includes/all.coffee\"\n  top = (top + \" \").trim() + \"\\n\"\n  source += top\n  source += addgenfunctions()\n  source += fs.readFileSync \"#{__dirname}/main/main.coffee\"\n  tmpname = \"#{__dirname}/main/tmp__#{uuid.v4()}\"\n  fs.writeFileSync tmpname + '.coffee', source\n  tmpname\n\nexports.load = ->\n  generators.makeFunctions()\n  list = ((firstprop plugin) for plugin in plugins when firstval(plugin) is on)\n  loadall pl for pl in list\n  maintmp = loadalltypes list\n  loadall 'main'\n  main = require maintmp\n  fs.unlinkSync \"#{maintmp}.coffee\"\n  if not main.run?\n    console.log \"Loader error: main must export run()\"\n    false\n  else\n    generators.generateAll('app', main.run)\n    true\n\n"},"nowjs":{"isdir":true,"server.coffee":{"isdir":false,"text":"#startexports\nexpressapp = (func) ->\n  text \"\"\"\n       nowjs = require 'now'\n       everyone = nowjs.initialize app\n       \"\"\"\n"},"client.coffee":{"isdir":false,"text":"#startexports\nhead = ->\n  mustinclude headitems 'js/now.js'\n"},"files":true},"souuid.coffee":{"isdir":false,"text":"#http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript\n#http://stackoverflow.com/users/3560/john-millikin\nS4 = ->\n  (((1+Math.random())*0x10000)|0).toString(16).substring(1)\n\nexports.S4 = S4\n\nexports.guid = ->\n   S4()+S4()+\"-\"+S4()+\"-\"+S4()+\"-\"+S4()+\"-\"+S4()+S4()+S4()\n\n"},"browserify.coffee":{"isdir":false,"text":"alert 'test'\n"},"generators.coffee":{"isdir":false,"text":"{html, head, body, text} = dk = require('drykup')()\n\nexports.dk = dk\n\nutil = require 'util'\nfs = require 'fs'\nuuid = require './souuid'\ncs = require 'coffee-script'\ncureutil = require './util'\n\nappendcall = (object, name, func) ->\n  funcs = \"#{name}_funcs\"\n  if (object[funcs])?\n    object[funcs].push func\n  else\n    object[funcs] = [ object[name], func ]\n  object[name] = cureutil.inseries object[funcs]\n\n\nmergeover = (object, properties) ->\n  for key, val of properties when key.indexOf('_funcs') < 0\n    if typeof val is \"function\"\n      appendcall object, key, val\n    else\n      object[key] = val\n  object\n\nexports.mergeover = mergeover\n\noutfile = null\n\ndeferred = {}\n\ndefer = (args) ->\n  uuid_ = uuid.guid()\n  deferred[uuid_] = args\n  ret = '{def' + uuid_ + '}'\n  text ret\n\nreplacedeferred = (rendered) ->\n  defers = rendered.match /\\{def.+\\}/gi\n\n  if defers? then for found in defers\n    uuid_ = found.substr(4)\n    uuid_ = uuid_.substr(0, uuid_.length-1)\n    dk.resetHtml()\n    deferred[uuid_]()\n    rendered = rendered.replace found, dk.htmlOut\n  rendered\n    \ndeferredtemplate =  ->\n  replacedeferred rendered, deferred\n\ncurrgen = null\n\nnewfile = (file) ->\n  if outfile?\n    output = dk.htmlOut\n    if output? and output.length > 0\n      newout = replacedeferred output\n      fs.writeFileSync \"#{currgen.path}/#{outfile}#{currgen.ext}\", newout\n      dk.resetHtml()\n  outfile = file\n  dk.resetHtml()\n\nclass FileGenerator\n  constructor: (@name, @path, @ext = '') ->\n    @funcs = {}\n\n  add: (funcs) ->\n    @funcs = mergeover @funcs, funcs\n  \n  run: (name, func) ->\n    try\n      currgen = @\n      outfile = name\n      dk.resetHtml()\n      setContext @name\n      func()\n      output = dk.htmlOut\n      newout = replacedeferred output\n      ret = fs.writeFileSync(\"#{@path}/#{outfile}#{@ext}\", newout)\n      \n    catch error\n      console.log \"File generation error. Generator name is #{@name} and path is #{@path}.\" +\n                  \"Error in #{name} function #{func}. Message is #{error}\"\n      process.exit(1)\n\ngenerators =\n  client: new FileGenerator 'client', 'views', '.html'\n  server: new FileGenerator 'server', '.', '.coffee'\n  jsclient: new FileGenerator 'jsclient', 'views'\n  types: new FileGenerator 'types', '/tmp', '.tmp'\n\naddToAll = (funcs) ->\n  for name, gen of generators\n    gen.add funcs\n\nexports.generators = generators\n\nmustinclude = (items, item) ->\n  if not (item in items)\n    items.push item\n  else\n   console.log 'not adding item'\n\naddToAll\n  replacedeferred: replacedeferred\n  deferred: deferred\n  defer: defer\n  mustinclude: mustinclude\n  outfile: outfile\n  newfile: newfile\n  currgen: currgen\n\nsetContext = (context) ->\n  exports.context = context\n\nexports.setContext = setContext\n\naddfunc = (name, func) ->\n  exports.functions[name] = (allargs...) ->\n    funcs = generators[exports.context].funcs\n    try\n      if funcs[name]?\n        funcs[name](allargs...)\n      else\n        console.log exports.context + '.' + name + ' not defined, skipping'\n    catch error\n      console.log \"Generation error: name = #{name}  func = #{util.inspect func}. Error is #{error}\"\n      process.exit 1\n\nexports.addAll = (gen, funcarr) ->\n  mergeover generators[gen].funcs, funcarr\n\nexports.functions = {}\n\nexports.makeFunctions = ->\n  for generator, val of generators\n    for funcname, func of val.funcs\n      addfunc funcname, func\n\nexports.generateAll = (name, func) ->\n  for gen, generator of generators\n    currgen = generator\n    generator.funcs[currgen] = generator\n    generator.run name, func\n\nexports.include = (name) ->\n  source = fs.readFileSync \"./includes/#{name}.coffee\"\n  cs.eval source\n\n\n"},"config.coffee":{"isdir":false,"text":"exports.config =\n  host: 'localhost'\n  port: 27017\n  db: 'app'\n"},"views":{"isdir":true,"todo":{"isdir":false,"text":"<!DOCTYPE html><html>null<body><input /></body></html>"},"files":true},"loader.coffee":{"isdir":false,"text":"fs = require 'fs'\nplugins = require './plugins'\ngenerators = require './generators'\ncs = require 'coffee-script'\nuuid = require 'node-uuid'\nutil = require 'util'\npathx = require 'path'\ngen = generators\nMongolianDeadBeef = require 'mongolian'\ncureutil = require './util'\nsecurity = require './security/security'\n\n\n\nfirstprop = (obj) ->\n  props = (prop for prop, val of obj)\n  props[0]\n\nfirstval = (obj) ->\n  vals = (val for prop, val of obj)\n  vals[0]\n\nstrip = (def) ->\n  def.substr(0, def.length-1).trim()\n\ndropext = (file) ->\n  file.substr 0, file.indexOf('.')\n\nwrap = (source, file) ->\n  if not file? or file is '.' or file is '..' then return ''\n  file = dropext file\n  source = (source + \" \").trim()\n  top = fs.readFileSync \"#{__dirname}/includes/all.coffee\"\n  top = (top + \" \").trim() + \"\\n\"\n  inc = ''\n  if pathx.existsSync \"#{__dirname}/includes/#{file}.coffee\"\n    inc = fs.readFileSync \"#{__dirname}/includes/#{file}.coffee\"\n  declares = ''\n  if generators.generators[file]?\n    funcs = generators.generators[file].funcs\n    if funcs? and Object.keys(funcs)? and Object.keys(funcs).length > 0\n      declares = '{ ' + Object.keys(funcs).join() + '}'\n      declares = \"#{declares} = gen.generators.#{file}.funcs\\n\"\n  bounds = \"#startexports\\n\"\n  bottom = ''\n  start = source.indexOf bounds\n  if start >= 0\n    exports = source.substr(start + bounds.length)\n    defs = exports.match /^[a-z0-9]+[ ]*[=]+/gmi\n    if defs?\n      list = (\"#{strip def}:#{strip def}\" for def in defs)\n      bottom = \"gen.addAll '#{file}', {#{list.join()}}\"\n  else\n    console.log \"No #startexports in #{file}\"\n    return ''\n  top + inc + \"\\n\" + declares + source + \"\\n\" + bottom\n\ncseval = (filename) ->\n  code = fs.readFileSync filename\n  code = code.toString()\n  compiled = cs.compile code, bare:on\n  eval compiled\n\nprocess = (path, fname) ->\n  console.log \"Processing file #{path}/#{fname}\"\n  if not pathx.existsSync \"#{path}/#{fname}\"\n    false\n  else\n    stats = fs.statSync \"#{path}/#{fname}\"\n    if stats.isDirectory() then return false\n    if not fname in [ 'client.coffee', 'server.coffee', 'jsclient.coffee']\n      require \"#{path}/#{fname}\"\n      return\n    source = fs.readFileSync \"#{path}/#{fname}\"\n    source = wrap source, fname\n    tmpname = \"#{path}/tmp__#{fname}_#{uuid.v4()}\"\n    fs.writeFileSync tmpname + '.coffee', source\n    cseval tmpname + '.coffee'\n    #r = require tmpname\n    fs.unlinkSync tmpname + '.coffee'\n\nloadall = (plugin) ->\n  path = \"#{__dirname}/#{plugin}\"\n  files = fs.readdirSync path\n  for f in files when f isnt 'types.coffee' and f isnt 'main.coffee' and f.indexOf('tmp__') isnt 0\n    process path, f\n  generators.makeFunctions()\n\naddgenfunctions = ->\n  funcs = generators.functions\n  declares = ''\n  if funcs? and Object.keys(funcs)? and Object.keys(funcs).length > 0\n    declares = '{ ' + Object.keys(funcs).join() + '}'\n    declares = \"#{declares} = gen.functions\\n\"\n  declares\n\nloadalltypes = (list) ->\n  source = ''\n  list.push 'main'\n  for pl in list\n    path = \"#{__dirname}/#{pl}/types.coffee\"\n    if pathx.existsSync(path)\n      source += fs.readFileSync path\n  top = fs.readFileSync \"#{__dirname}/includes/main.coffee\"\n  top = (top + \" \").trim() + \"\\n\"\n  source += top\n  source += addgenfunctions()\n  source += fs.readFileSync \"#{__dirname}/main/main.coffee\"\n  tmpname = \"#{__dirname}/main/tmp__#{uuid.v4()}\"\n  fs.writeFileSync tmpname + '.coffee', source\n  tmpname\n\nexports.load = ->\n  generators.makeFunctions()\n  list = ((firstprop plugin) for plugin in plugins when firstval(plugin) is on)\n  loadall pl for pl in list\n  maintmp = loadalltypes list\n  loadall 'main'\n  main = require maintmp\n  fs.unlinkSync \"#{maintmp}.coffee\"\n  if not main.run?\n    console.log \"Loader error: main must export run()\"\n    false\n  else\n    generators.generateAll('app', main.run)\n    true\n\n"}}